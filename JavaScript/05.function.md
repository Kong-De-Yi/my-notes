# 递归与堆栈

- 任务可拆成多个相同类型但更简单的任务
- 函数调用自身
- 任何递归都可以用循环来重写

## 递归函数

- x<sup>n</sup>=x \* x<sup>n-1</sup>

```javascript
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
```

## 递归遍历

```javascript
let company = {
  sales: [
    { name: "John", salary: 1000 },
    { name: "Alice", salary: 1600 },
  ],
  development: {
    sites: [
      { name: "Peter", salary: 2000 },
      { name: "Alex", salary: 1800 },
    ],
    internals: [{ name: "Jack", salary: 1300 }],
  },
};

function sumSalaries(department) {
  if (Array.isArray(department)) {
    return department.reduce((prev, current) => prev + current.salary, 0);
  } else {
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep);
    }
    return sum;
  }
}

alert(sumSalaries(company));
```

## 递归结构

- 递归数据结构是一种部分复制自身的结构

# Rest 参数与 Sread 语法

- 支持传入任意数量参数的函数
- 将数组作为参数传递给函数

## Rest 参数 ...

- 默认情况下可以给函数传递任意数量的参数（多余的参数会被忽略）

```javascript
function sum(a, b) {
  return a + b;
}
alert(sum(1, 2, 3, 4, 5)); //3
```

- 解决：声明一个数组来收集多余的参数（Rest 参数）

```javascript
//所有参数都放进Rest参数
function sumAll(...args) {
  let sum = 0;
  for (let arg of args) {
    sum += arg;
  }
  return sum;
}
alert(sumAll(1)); //1
alert(sumAll(1, 2)); //3
alert(sumAll(1, 2, 3)); //6
//将多有的参数放进Rest参数
function showName(firstName, lastName, ...titles) {
  alert(firstName + " " + lastName); //Julius Caesar
  alert(titles[0]); //Consul
  alert(titles[1]); //Imperator
  alert(titles.length); //2
}
showName("Julius", "Caesar", "Consul", "Imperator");
```

- Rest 参数必须放到参数列表的末尾

```javascript
//Error
function f(arg1,...rest,arg2){...}
```

## arguments 变量

- 函数内部的类数组对象，存放函数的所有参数（在参数列表中索引作为键）
- 是可迭代的（可以用 for...of 遍历）
- 箭头函数没有 arguments（能访问到的是外部普通函数的 arguments 参数）

```javascript
function showName() {
  alert(arguments.length);
  alert(arguments[0]);
  alert(argumengs[1]);

  //可以遍历参数
  for (let arg of arguments) {
    alert(arg);
  }
}
showName("Julius", "Caesar"); //2 Julius Caesar
showName("Ilya"); //1 Ilya undefined

function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}
f(1); //1
```

## Spread 语法

- 将可迭代对象展开到参数列表中
- 可以合并数组

```javascript
let arr = [3, 5, 1];
alert(Math.max(...arr)); //5

//传入多个可迭代对象
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
alert(Math.max(...arr1, ...arr2)); //8

//和常规参数混合使用
alert(Math.max(1, ...arr1, 2, ...arr2, 25)); //25

//合并数组
let merged = [0, ...arr1, 2, ...arr2]; //0,1,-2,3,4,2,8,3,-8,1

//转换字符串
let str = "Hello";
alert([...str]); //H,e,l,l,o
```

## Spread 语法复制 array/object

```javascript
//复制数组
let arr = [1, 2, 3];
let arrCopy = [...arr];
//复制对象
let obj1 = { foo: "bar", x: 42 };
let obj2 = { foo: "bar", y: 13 };
let clonedObj = { ...obj1, ...obj2 };
```

# 变量作用域

## 代码块`{...}`

- 代码块内声明的变量只在该代码块内可见
- if,for 和 while 都有自己的代码块{...}

```javascript
{
  let message = "Hello";
  alert(message);
}
alert(message); //Error:message is not defined
```

## 嵌套函数

```javascript
function sayHiBye(firstName, lastName) {
  function getFullName() {
    return firstName + " " + lastName; //可以访问外部变量
  }
  alert("Hello, " + getFullName());
  alert("Bye, " + getFullName());
}

function makeCounter() {
  let count = 0;
  return function () {
    return count++;
  };
}

let counter = makeCounter();
alert(counter()); //0
alert(count()); //1
alert(count()); //2
```

## 词法环境对象

- 函数，代码块以及整个脚本，都有一个"词法环境"内部（隐藏）关联对象
  - 环境记录：存储所有局部变量作为其属性（获取或修改变量 —> 获取或修改词法环境的属性）
  - 外部引用：对外部词法环境的引用
- 函数有自己的内部词法环境，存储局部变量和参数
- 当代码要访问一个变量时，首先搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，直到全局词法环境

### 变量

脚本运行——>变量（uninitialized)——>let 变量（undefined)——>变量被赋值

### 函数声明

函数声明的初始化会被立即完成

### 返回函数（闭包）

函数在**定义**时就引用了创建它们的词法环境，并会在该词法环境中更新变量

## 垃圾收集

- 词法环境对象仅在可达时才会保留在内存

```javascript
function f() {
  let value = 123;
  return function () {
    alert(value);
  };
}

let g = f(); //g.[[Environment]]存储了对f()调用的词法环境的引用
//清除词法环境
g = null;
```

# var 声明

- var 没有块级作用域，只有函数作用域和全局作用域

```javascript
if (true) {
  var test = true; //相当于定义了全局作用域变量
}
alert(test); //true，可见

function sayHi() {
  if (true) {
    var test = true; //函数作用域
  }
  alert(test); //true
}
alert(test); //ReferenceError:test is not defined
```

- var 允许重新声明，新的声明语句会被忽略

```javascript
var user = "Pete";
var user = "John";
alert(user); //John
```

- var 声明的变量可以在声明前使用
  var 声明的变量会在函数开头被定义，与它在代码中的位置无关（提升）
  **变量声明会被提升，但赋值不会**

```javascript
function sayHi() {
  alert(phrase); //undefined
  var phrase = "Hello";
}
```

# 全局对象

- 全局对象提供可在任何地方使用的变量和函数，内建于语言或环境中
  - 标准名称：globalThis
  - 浏览器：window
  - Node.js：global

```javascript
alert("Hello");
window.alert("Hello"); //等效
```

- 浏览器中，使用 var 声明的变量和函数会成为全局对象的属性

```javascript
var gVar = 5;
alert(window.gVar); //5
```

- 一般不建议使用全局变量

```javascript
window.currentUser = {
  name: "Jhon",
};
alert(currentUser.name);
```

# 函数对象

- 函数的类型是对象：可被调用的"行为对象"
- 函数除了完成一项工作，还可以在自身属性中附带其他功能

## 属性：name

- 函数的名字
- 名称赋值的逻辑是智能的（上下文命名）

```javascript
function sayHi() {
  alert("Hi");
}
alert(sayHi.name); //sayHi
//名称赋值
let sayHi = function () {
  alert("Hi");
};
alert(sayHi.name); //sayHi
//默认值赋值
function f(sayHi = function () {}) {
  alert(saiHi.name); //saiHi
}
f();
//对象方法也有名字
let user = {
  sayHi() {
    alert("Hi");
  },
  sayBye: function () {
    alert("Bye");
  },
};
alert(user.sayHi.name); //sayHi
alert(user.sayBye.name); //sayBye
```

## 属性：length

- 函数入参的个数（rest 参数不参与计数）

```javascript
function f1(a) {}
function f2(a, b) {}
function f3(a, b, ...more) {}
alert(f1.length); //1
alert(f2.length); //2
alert(f3.length); //2
```

- 应用：多态性

```javascript
function ask(question, ...handlers) {
  let isYes = confirm(question);
  for (let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }
}
ask(
  "Question?",
  () => alert("You said yes"),
  (result) => alert(result),
);
```

## 自定义属性

- 给函数对象添加我们自己的属性
- **赋值给函数的属性和函数局部变量是毫不相关的两个东西**
- 有时可代替闭包，但是外部代码可直接访问

```javascript
//跟踪函数调用次数
function sayHi() {
  alert("Hi");
  sayHi.counter++;
}
sayHi.counter = 0;
saiHi();
sayHi();
alert(`Called ${sayHi.counter}times`); //Called 2 times

//代替闭包
function makeCounter() {
  function counter() {
    return counter.count++;
  }
  counter.count = 0; //count被存储在函数属性中，不在外部的词法环境
  return counter;
}
let counter = makeCounter();
alert(counter()); //1
alert(counter()); //2
counter.count = 10; //外部代码可直接访问
```

## 命名函数表达式（ NFE）

- 带有名字的函数表达式(func)
- 允许函数在内部引用自己
- 在函数外是**不可见**的

```javascript
let sayHi = function func(who) {
  if (who) {
    alert(`Hello,${who}`);
  } else {
    func("Guest"); //函数内部用func调用自己
  }
};
sayHi(); //Hello,Guest
func(); //Error,func is not defined
```

- 存在的意义

```javascript
let sayHi = function () {
  if (who) {
    alert(`Hello,${who}`);
  } else {
    sayHi("Guest");
  }
};
let welcome = sayHi;
saiHi = null;
welcome(); //Error,saiHi无效
```

# New Function 语法

- 将任意字符串变为函数
- 创建的函数词法环境永远指向全局环境
- 语法：`let func=new Function([arg1,arg2,...,argN],functionBody);`

```javascript
new Function("a", "b", "return a+b");
new Function("a,b", "return a+b");
new Function('alert("Hello")');
```

# 计划调用

- 传入调度程序中的函数会被调度程序引用，防止被GC回收
- 传入调度程序中的函数如果引用了外部变量会形成闭包
- 忽略delay参数会在当前脚本执行完成之后才立即执行，并有4ms强制延时

## setTimeout：推迟执行

- 语法：`let timerId=setTimeout(func|code,[delay],[arg1],[arg2],...)`
  - func|code：要执行的函数或代码字符串
  - delay：延时的毫秒数，默认 0
  - arg1,arg2...：传入函数或代码字符串的参数列表
  - 返回定时器标识符
- clearTimeout：取消执行

```javascript
function sayHi(phrase, who) {
  alert(phrase + "," + who);
}
setTimeout(sayHi, 1000, "Hello", "John"); //1秒后执行

setTimeout('alert("Hello")', 1000); //会自动创建一个函数，不建议
setTimeout(() => alert("Hello"), 1000); //用箭头函数代替
//取消执行
let timerId = setTimeout(() => alert("Hello"), 1000);
clearTimeout(timerId);
```

## setInterval：周期执行

- 语法：`let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)`
- func执行时间会消耗间隔时间
- clearInterval：取消执行

```javascript
//每2秒执行一次
let timerId = setInterval(() => alert("tick"), 2000);
//5秒后停止重复执行
setTimeout(() => {
  clearInterval(timerId);
  alert("stop");
}, 5000);
```

## 嵌套setTimeout：更灵活更精确

- 在嵌套setTimeout前根据情况调整delay
- 下一次调用是在前一次调用完成后再调度

```javascript
let timerId = setTimeout(function tick() {
  console.log("tick");
  timerId = setTimeout(tick, 2000);
}, 2000);

//根据服务器过载降低请求频率
let delay = 5000;
let timerId = setTimeout(function request() {
  //...发送请求
  if ("request failed due to server overload") {
    delay *= 2;
  }
  timerId = setTimeout(request, delay);
}, delay);
```

# 装饰器

## 装饰普通函数

- 接受函数作为参数，并返回改变了行为的包装器函数
- 装饰器是可重用的
- 没有改变被装饰函数本身的逻辑
- 可以组合多个装饰器
- 包装器会丢失原始函数属性

```javascript
//CPU重负载任务
function slow(x) {
  alert(`Called with ${x}`);
  return x;
}
//装饰器
function cachingDecorator(func) {
  let cache = new Map();
  //返回包装器函数
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x);
    cache.set(x, result);
    return result;
  };
}
slow = cachingDecorator(slow); //应用装饰器函数
alert(slow(1)); //1
alert(slow(1)); //使用cache中的缓存结果
```

## 装饰对象方法

- 包装器函数调用对象方法时，上下文this=undefined

```javascript
let worker = {
  someMethod() {
    return 1;
  },
  slow(x) {
    alert(`Called with ${x}`);
    return x * this.someMethod();
  },
};
//装饰器
function cachingDecorator(func) {
  let cache = new Map();
  //返回包装器函数
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); //正确写法：let result=func.call(this,x);
    cache.set(x, result);
    return result;
  };
}
//应用缓存装饰器
worker.slow = cachingDecorator(woker.slow);
alert(worker.slow(2)); //Error,Can not read property 'someMethod' of undefined
```

- 显式设置this的值`func.call(context,arg1,arg2,...);`

```javascript
function say(phrase) {
  alert(this.name + ":" + phrase);
}
let user = { name: "John" };
let admin = { name: "Admin" };
say.call(user, "Hello"); //John:Hello
```

## 传递多个参数

```javascript
let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  },
};
//装饰器
function cachingDecorator(func, hash) {
  let cache = new Map();
  return function () {
    let key = hash(arguments); //使用函数的参数数组
    if (cache.has(key)) {
      return cache.get(key);
    }
    let result = func.call(this, ...arguments);
    cache.set(key, result);
    return result;
  };
}
//哈希函数
function hash(args) {
  return args[0] + "," + args[1];
}
worker.slow = cachingDecorator(worker.show);
alert(worker.show(3, 5));
```

## 呼叫转移：func.apply

- func.apply(context,args)
- 直接使用类数组对象作为参数列表,不需要Spread...
- 速度更快

```javascript
let wrapper = function () {
  return func.apply(this, arguments);
};
```

## 方法借用

```javascript
function hash() {
  alert([].join.call(arguments)); //this=arguments
}
hash(1, 2); //1,2
```

# 函数绑定

- 解决this的丢失问题

```javascript
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello,${this.firstName}`);
  },
};
setTimeout(user.sayHi, 1000); //Hello,undefined
```

## 方案1：包装器

- 漏洞：user的值可能改变，调用了错误的对象方法

```javascript
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello,${this.firstName}`);
  },
};
setTimeout(function () {
  user.sayHi();
});
//箭头函数写法
setTimeout(() => user.sayHi(), 1000);
```

## 方案2：bind函数

- 语法：`let boundFunc = func.bind(context,[arg1],[arg2],...)`\
- boundFunc就像绑定了this=context的func,省略参数将原样传递给func

```javascript
let user = {
  firstName: "John",
};
function func() {
  alert(this.firstName);
}
let funcUser = func.bind(user);
funcUser(); //John
//绑定对象方法
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello,${this.firstName}`);
  },
};
let sayHi = user.sayHi(user);
sayHi(); //Hello,John,可以在没有对象的情况下调用
setTimeout(sayHi, 1000); //Hello,John
//绑定对象的所有方法
for (let key in user) {
  if (typeof user[key] == "function") {
    user[key] = user[key].bind(user);
  }
}
```

- bind绑定部分参数：函数的部分应用

```javascript
function mul(a, b) {
  return a * b;
}
//绑定参数
let double = mul.bind(null, 2); //this=null,将2绑定为参数a
alert(double(3)); //=mul(2,3)=6
alert(double(4)); //=mul(2,4)=8
```

# 绑定部分参数的装饰器

```javascript
function partial(func, ...argsBound) {
  return function (...args) {
    return func.call(this, ...argsBound, ...args);
  };
}
let user = {
  firstName: "John",
  say(time, phrase) {
    alert(`$[time]${this.firstName}:${phrase}!`);
  },
};
user.sayNow = partial(
  user.say,
  new Date().getHours() + ":" + new Date().getMinutes(),
);
user.sayNow(); //[10:00]John:Hello!
```

# 箭头函数

- 没有this
- 没有arguments
- 没有super
- 不能使用new调用

```javascript
//没有this
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],
  showList() {
    this.students.forEach((student) => alert(this.title + ":" + student));
  },
};
group.showList();
//没有arguments
function defer(f, ms) {
  return function () {
    setTimeout(() => f.apply(this, arguments), ms);
  };
}
function sayHi(who) {
  alert("Hello," + who);
}
let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("John");
//不用箭头函数的写法
function defer(f, ms) {
  return function (...args) {
    let ctx = this;
    setTimeout(function () {
      return f.apply(ctx, args);
    }, ms);
  };
}
```
