# 原始类型的方法

## 需求：使用方法对原始类型执行操作

- 解决方案：对象包装器（String、Number、Boolean、Symbol、Bigint）
- 实现原理：访问原始值的属性时，创建对象包装器对象，访问结束就销毁

```javascript
let str = "hello";
alert(str.toUpperCase()); //HELLO

let n = 1.23456;
alert(n.toFixed(2)); //1.23
```

- 构造器 String/Number/Boolean 仅供内部使用

```javascript
alert(typeof 0); //"number"
alert(typeof new Number(0)); //"object"

let zero = new Number(0);
if (zero) {
  //zero是对象，始终为true
  alert("zero is truthy?!?");
}
```

- 调用不带"new"的 String/Number/Boolean 有效

```javascript
let num = Number("123"); //将字符串转换为数字
```

- null 和 undefined 没有对象包装器，也没有任何方法

# 数字类型

- Number：双精度浮点数（64 位 IEEE-754 格式），范围 ±($2^{53}$-1)
- Bigint：任意长度的整数

## 数字的更多写法

```javascript
let billion = 1000000000;
let billion = 1_000_000_000; //更具可读性的写法，_会被javascript引擎忽略

//e后面的正数表示乘以1后面跟着指定数量的0的数字
1e3 === 1 * 1000; //e3表示*1000
1.23e6 === 1.23 * 1000000; //e6表示*1000000

//e后面的负数表示除以1后面跟着指定数量的0的数字
1e-3 === 1 / 1000; //e-3表示/1000
1.23e-6 === 1.23 / 1000000; //e-6表示/1000000
1234e-2 === 1234 / 100; //e-2表示/100
```

## 不同的进制

- 十六进制：`0xff`、`0xFF`(255)
- 二进制：`0b11111111`(255)
- 八进制：`0o377`(255)
- `toString(base)`：
  - 返回 base 进制中的字符串表示形式
  - base 取值范围 2-36，默认 10

```javascript
let num = 255;
alert(num.toString(16)); //ff
alert(num.toString(2)); //11111111
```

- 使用两个点来调用方法(或者括号)：
  `let num = 123456789..toString(36); //'21i3v9'`
  `let num = (123456789).toString(36); //'21i3v9'`

## 数字的舍入

- 舍入到整数
  - Math.floor：向下舍入，3.1 —> 3,-1.1 —> -2
  - Math.ceil：向上输入，3.1 —> 4,-1.1 —> -1
  - Math.round：向最接近的整数舍入，3.1 —> 3,3.6 —> 4，3.5 —> 4
  - Math.trunc：截断取整，3.1 —> 3,-1.1 —> -1
- 舍入到小数点后 n 位
  - 乘除法
  - toFixed(n)：将数字舍入到小数点后 n 位，并返回字符串形式，向最接近的值输入，类似 Math.round

```javascript
let num = 1.23456;
alert(Math.round(num * 100) / 100); //1.23456—>123.456—>123—>1.23

let num = 12.36;
alert(num.toFixed(1)); //"12.4"
alert(num.toFixed(5)); //"12.36000"，在末尾添加0
```

## 不精确的计算

- 64 位格式存储 —> 数据溢出`alert(1e500);//Infinity`
- 二进制下无限循环小数 —> 精度损失

```javascript
alert(0.1 + 0.2 == 0.3); //fasle
alert(0.1 + 0.2); //0.30000000000000004
alert((0.1).toFixed(20)); //0.10000000000000000555
```

- 解决办法：`toFixed(n)`,返回 string

```javascript
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); //"0.30"
alert(+sum.toFixed(2)); //0.3
```

- 乘除法可以减少误差，不能完全消除误差

## 测试：isFinite 和 isNaN

- `isNaN(value)`：将 value 转化为数字后测试是否为 NaN（===NaN 始终返回 false，无法测试）

```javascript
alert(isNaN(NaN)); //true
alert(isNaN("str")); //true
alert(NaN === NaN); //false
```

- `isFinite(value)`：将 value 转化为数字后测试是否为$ \pm $ Infinity 或 NaN，否则返回 true

```javascript
alert(isFinite("15")); //true
alert(isFinite("str")); //false,转化结果为NaN
alert(isFinite(Infinity)); //fasle

//验证输入值是否为常规数字
let num = +prompt("Enter a number", "");
alert(isFinite(num)); //
```

- `Object.is(a,b)`：类似 ===，边缘情况更可靠
  - `Object.is(NaN,NaN) === true`
  - `Object.is(+0,-0) === false`
  - 其他情况`Object.is(a,b)`与`a === b`相同

## 智能提取数字（parseInt 和 parseFloat）

- 从字符串中读取数字，直到无法读取为止

```javascript
alert(parseInt("100px")); //100
alert(parseInt("12.3")); //12，只返回整数

alert(parseFloat("12.5em")); //12.5
alert(parseFloat("12.3.4")); //12.3,第二个点处停止了读取

alert(parseInt("a123")); //NaN,第一个符号停止了读取
```

- `parseInt(str,[radix])`:radix 可选，指定数制解析多进制下的字符串

```javascript
alert(parseInt("0xff", 16)); //255
alert(parseInt("ff"), 16); //255，没有0x依然有效
alert(parseInt("2n9c", 36)); //123456
```

## 内建对象：Math

- `Math.random()`:返回[0.0,1.0)范围的随机数
- `Math.max(arg1,arg2,...,argN)`和`Math.min(arg1,arg2,...,argN)`：返回最大值和最小值
- `Math.pow(n,power)`：返回 n 的 power 次幂

# 字符串

- 单个字符没有特有的类型
- 内部编码：UTF-16

## 转义字符

- \n —> 换行
- \\' —> 单引号
- \\\" —> 双引号
- \\\ —> 反斜线
- \xXX —> 十六进制 Unicode 码的对应字符，"\x7A" —> "z"
- \uXXXX —> 十六进制 UTF-16 编码的对应 Unicode 字符，"\u00A9" —> "©"
- \u{X...XXX} —> 十六进制 UTF-32 编码的对应 Unicode 字符
- 只有与外部闭合引号相同的引号才需要转义

```javascript
let str = `I'm the Walrus!`; //I'm the Walrus!
let str = "I'm the Walrus!"; //I'm the Walrus!
let str = `The backslash：\\`; //The backslash：\
```

## 字符串长度：属性`length`

```javascript
alert(`My\n`.length); //3
```

## 访问字符串中的字符

- 第一个字符位置：0
- `str[pos]`：返回 pos 位置的字符，没有返回 undefined
- `str.charAt(pos)`：返回 pos 位置的字符，没有返回空字符串

```javascript
let str = `Hello`;
alert(str[0]); //H
alert(str.charAt(0)); //H
alert(str[str.length - 1]); //返回最后一个字符
alert(str[1000]); //undefined
alart(str.charAt(1000)); //""
```

- 遍历字符：for...of

```javascript
for (let char of "Hello") {
  alert(char); //H,e,l,l,o
}
```

## 字符串是不可变的

```javascript
let str = "Hi";
str[0] = "h"; //error

str = "h" + str[1]; //替换字符串
```

## 改变大小写

- `toUpperCase()`：返回大写形式
- `toLowerCase()`：返回小写形式

## 查找子字符串

### str.indexOf(substr,[pos])

- 从 pos 位置（可选）**向右**查找子字符串 substr**第一次**出现在 str 中的位置（区分大小写）
- 返回查找到的位置，没有返回 -1

```javascript
let str = "Widget with id";
alert(str.indexOf("Widget")); //0
alert(str.indexOf("widget"));
-1; //没有找到，大小写敏感
alert(str.indexOf("id")); //1
alert(str.indexOf("id", 2)); //12，从位置2开始检索

//检索所有匹配的位置
let str = "As sly as a fox,as strong as an ox";
let target = "as";
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert(pos);
}
```

- 不方便的地方

```javascript
let str = "Widget with id";
//不会工作，indexOf返回0，布尔转换为false
if (str.indexOf("Widget")) {
  alert("We found it");
}
//正确写法
if (str.indexOf("Wigdet") != -1) {
  alert("We found it");
}
```

- 使用按位（bitwise）NOT 技巧
  - 原理 ~n == - (n+1) 即 ~ (-1) == - 0
  - `if(str.indexOf(...) != -1)`可简写为`if(~str.indexOf(...))`

### str.lastIndexOf(substr,[pos])

- 从 pos 位置（可选）**向左**查找子字符串 substr**最后一次**出现在 str 中的位置（区分大小写）
- 返回查找到的位置，没有返回 -1

### str.includes(substr,[pos])

- 从 pos 位置（可选）查找确认是否包含子字符串 substr（区分大小写）
- 返回 true/false

### str.startsWith(substr)与 str.endsWith(substr)

- 确认是否以子字符串 substr 开始（结尾）
- 返回 true/false

## 获取子字符串

### str.slice(start,[end])

- 返回字符串从 start 到 end（不含）的部分
- end 可选，无则截取到字符串末尾
- start/end 可为负数，从末尾开始计算
- start 必须小于 end，否则返回空字符串

```javascript
let str = "stringify";
alert(str.slice(-4, -1)); //'gif',从右边第4个位置开始到右边的第1个位置结束
```

### str.substring(start,[end])

- 返回字符串从 start 到 end（不含）的部分
- end 可选，无则截取到字符串末尾
- 不支持负参数，被视为 0
- start 可以大于 end

```javascript
let str = "stringify";
alert(str.substring(2, 6)); //"ring"
alert(str.substring(6, 2)); //"ring"

alert(str.slice(2, 6)); //"ring"
alert(str.slice(6, 2)); //""(空字符串)
```

### str.substr(start,[length])

- 返回字符串从 start 开始 length 长度的部分
- length 可选，无则截取到字符串末尾
- start 可为负数，从末尾开始计算

```javascript
let str = "stringify";
alert(str.substr(-4, 2)); //"gi",从右边第4个位置开始取2个字符
```

## 比较字符串

- 通过 UTF-16 编码进行比较，编码越大字符越大

### str.codePointAt(pos)

- 返回在 pos 位置的字符 UTF-16 编码

### String.fromCodePoint(code)

- 通过 UTF-16 编码 code 创建字符

```javascript
alert("z".codePointAt(0)); //122
alert("Z".codePointAt(0)); //90
alert(String.fromCodePoint(90)); //Z
alert("\u005a"); //Z
```

### 正确比较：str.localeCompare(str2)

- str 在 str2 前，返回负数
- str 在 str2 后，返回正数
- 位置相同，返回 0

## 常用字符串方法：

- `str.trim()`：删除字符串前后的空格
- `str.repeat(n)`：重复字符串 n 次

# 数组

## 用途：存储有序的元素集合

- 本质是一种特殊的对象（通过引用复制）
- 元素可以是任何类型

## 数组的创建（声明）

```javascript
//创建空数组
let arr = new Array();
let arr = [];

//创建指定长度的空数组
let arr = new Array(2);
alert(arr[0]); //undefined,没有元素
alert(arr.length); //2

//添加初始元素
let fruits = new Array("Apple", "Pear", "etc");
let fruits = ["Apple", "Orange", "Plum"];
alert(fruits); //Apple,Orange,Plum

//混合类型元素
let arr = [
  "Apple",
  { name: "John" },
  true,
  function () {
    alert("Hello");
  },
];
alert(arr[1].name); //John
arr[3](); //Hello
```

- 清空数组：`arr.length = 0;`（修改 length 属性）
- 最后一个元素以逗号结尾，方便添加，删除和移动元素

## 元素的访问

- 数组元素从 0 开始编号
- 使用方括号索引获取

```javascript
let fruits = ["Apple", "Orange", "Plum"];
alert(fruits[0]); //Apple
fruits[2] = "Pear"; //替换元素
fruits[3] = "Lemon"; //直接赋值添加元素
```

## 数组的长度：length 属性

```javascript
let fruits = ["Apple", "Orange", "Plum"];
alert(fruits.length); //3
```

## 获取最后一个元素：arr\.at(i)

- 索引方式不支持负向索引，arr[-1] —> undefined
- 常规方法：使用 length 属性
- 简便方法：使用 at(-1)

```javascript
let fruits = ["Apple", "Orange", "Plum"];
alert(fruits[fruits.length - 1]); //Plum
alert(fruits.at(-1)); //Plum
```

- 原理：i >= 0,与 arr[i]等效，i < 0,从数组尾部往前数

## 数组支持双端队列（deque）

### 队列（queue）：先进先出 FIFO（First-In-First-Out)

### 栈（stack）：后进先出 LIFO（Last-In-First-Out）

- push：在数组末端添加 n 个元素
- pop：删除并返回数组末端最后一个元素
- unshift：在数组首端添加 n 个元素
- shift：删除并返回数组首端第一个元素

```javascript
let fruits = ["Apple", "Orange"];

fruits.push("Pear");
alert(fruits); //Apple,Orange,Pear

alert(fruits.shift()); //Apple
alert(fruits); //Orange,Pear

fruits.unshift("Apple");
alert(fruits); //Apple,Orange,Pear

alert(fruits.pop()); //Pear
alert(fruits); //Apple,Orange

let fruits = ["Apple"];
fruits.push("Orange", "Pear");
fruits.unshift("Pineapple", "Lemon");
alert(fruits); //Pineapple,Lemon,Apple,Orange,Peach
```

- 末端操作（push/pop）比首端操作（shift/unshift)效率高（首端操作需要移动所有的元素）

## 以"有序集合"的方式使用数组

- 不要用常规对象方式使用，否则会失去 Javascript 引擎的优化
  - 不要添加非数字属性
  - 不要制造空洞
  - 不要倒序填充数组

```javascript
let arr = [];
//添加非数字属性
arr.test = 5;
//制造空洞，中间什么也没有
arr[0] = 0;
arr[1000] = 1000;
//倒序填充
arr[1000] = 1000;
arr[999] = 999;
```

## 遍历数组中的元素

- 常规 for 循环：同时获取索引和元素
- 专用 for...of：只能获取元素
- 对象方式：for...in：有潜在问题，会遍历**所有属性**

```javascript
let arr = ["Apple", "Orange", "Pear"];
//常规for循环
for (let i = 0; i < arr.length; i++) {
  alert(arr[i]);
}
//数组专用方式
for (let item of arr) {
  alert(item);
}
```

- arr.forEach(func)：为每个元素运行一次函数（忽略返回值）

```javascript
/*
item：元素
index：元素索引
array：元素所在的数组
*/
arr.forEach(function (item, index, array) {
  //do something with item
});
```

```javascript
//对每个元素调用alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) =>
  alert(`${item} is at index ${index} in ${array}`)
);
```

## 属性 length 的本质

- 最大的索引值 +1（不是元素的总个数）
- 可以修改，减小 length 会截断数组（不可逆）

```javascript
let arr = [];
arr[123] = "Apple";
alert(arr.length); //124

let arr = [1, 2, 3, 4, 5];
arr.length = 2;
alert(arr); //1,2

arr.length = 5;
alert(arr[3]); //undefined,数据丢失
```

## 多维数组（数组中的数组）

```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];
alert(matrix[1][1]); //5
```

## 数组的 toString()

- 返回逗号分隔的元素列表
- 数组没有 Symbol.toPrimitive 和 valueOf

```javascript
let arr = [1, 2, 3];
alert(arr); //1,2,3
alert(String(arr) === "1,2,3"); //true

alert([] + 1); //"1"
alert([1] + 1); //"11"
alert([1, 2] + 1); //"1,21"
```

## 比较数组

- 不要用 == 比较，数组按对象方式比较
- 遍历元素逐项比较

```javascript
alert([] == []); //false
alert([0] == [0]); //false

let arr1 = [1, 2, 3];
let arr2 = arr1;
alert(arr1 == arr2); //true

alert(0 == []); //true,[] —> "" —> 0
alert("0" == []); //false,[] —> ""
```

## 自由添加/移除数组元素

- delete 方法的潜在问题（不会移动剩下的元素，length 不变）

```javascript
let arr = ["I", "go", "home"];
delete arr[1];
alert(arr[1]); //undefined
alert(arr); //I,,home
alert(arr.length); //3
```

### arr.splice(start,[deleteCount,elem1,...,elemN])：添加/删除/插入

- 从 start 位置开始删除 deleteCount 个元素，并用 elem1,...elemN 替换它们
- 支持负向索引
- 返回删除元素组成的数组

```javascript
let arr = ["I", "sutdy", "JavaScript"];

arr.splice(1, 1); //从索引1开始删除1个元素
alert(arr); //I,JavaScript

let arr = ["I", "sutdy", "JavaScript"];
arr.splice(1); //从索引1开始删除后面所有的元素
alert(arr); //I

//删除元素并用新元素替换
let arr = ["I", "study", "JavaScript", "right", "now"];
let removed = arr.splice(1, 3, "Let's", "dance");
alert(removed); //study,JavaScript，right
alert(arr); //I,Let's，dance,now

//插入新元素(在start之前插入)
let arr = ["I", "study", "JavaScript"];
arr.splice(1, 0, "complex", "language");
alert(arr); //I,complex,language,study,JavaScript

//负向索引
let arr = [1, 2, 5];
arr.splice(-1, 0, 3, 4);
alert(arr); //1,2,3,4,5
```

### arr.slice([start],[end])：获取（子）数组副本

- 创建并返回新数组，复制[start,end)范围内的元素到新数组
- 支持负向索引
- 不影响原始数组

```javascript
let arr = ["t", "e", "s", "t"];
alert(arr.slice(1, 3)); //e,s
//负向索引
alert(arr.slice(-2)); //s,t
//创建数组副本
alert(arr.slice()); //t,e,s,t
```

### arr.concat(arg1,arg2...)：合并数组和元素

- 返回由 arr 中元素和参数解构后元素组成的新数组
- 只会解构具有 Symbol.isConcatSpreadable 的参数

```javascript
let arr = [1, 2];
alert(arr.concat([3, 4])); //1,2,3,4
alert(arr.concat([3, 4], [5, 6], 7, 8)); //1,2,3,4,5,6,7,8

let arrayLike = {
  0: "somethong",
  length: 1,
};
alert(arr.concat(arrayLike)); //1,2,[object Object]

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadble]: true,
  length: 2,
};
alert(arr.concat(arrayLike)); //1,2,something,else
```

## 查找元素

### arr.indexOf(item,[from])

- 从 from 位置（可选）开始**向右**查找 item,找到立即返回索引，否则返回-1
- 使用严格相等 === 进行比较
- 无法正确处理 NaN

### arr.includes(item,[from])

- 从 from 位置（可选）开始查找 item，找到返回 true，否则返回 false
- 使用严格相等 === 进行比较
- 可以正确处理 NaN

### arr.lastIndexOf(item,[from])

- 从 from 位置（可选）开始**向左**查找 item,找到立即返回索引，否则返回-1

```javascript
let arr = [1, 0, false];
alert(arr.indexOf(0)); //1
alert(arr.indexOf(false)); //2
alert(arr.indexOf(null)); //-1

alert(arr.includes(1)); //true

let fruits = ["Apple", "Orange", "Apple"];
alert(fruits.indexOf("Apple")); //0
alert(fruits.lastIndexOf("Apple")); //2

const arr = [NaN];
alert(arr.indexOf(NaN)); //-1,错误，应该是0
alert(arr.includes(NaN)); //true
```

## 在对象数组中查找符合条件的单个对象

### arr.find(func,[thisArg])

```javascript
/*
item：元素
index：元素索引
array：元素所在数组
*/
let result = arr.find(function (item, index, array) {
  //如果返回true，则返回item并停止迭代
  //如果返回false，则返回undefined
});
```

- **从左往右**遍历元素并调用 func,返回 true 则停止搜索并返回 item，没有则返回 undefined

```javascript
//找到 id == 1 的用户
let users = [
  { id: 1, name: "John" },
  { id: 2, name: "Pete" },
  { id: 3, name: "Mary" },
];

let user = users.find((item) => item.id == 1);
alert(user.name);
```

### arr.findIndex(func)

- **从左往右**遍历元素并调用 func,返回 true 则停止搜索并返回 index，没有则返回 -1

### arr.findLastIndex(func)

- **从右往左**遍历元素并调用 func,返回 true 则停止搜索并返回 index，没有则返回 -1

```javascript
let users = [
  { id: 1, name: "John" },
  { id: 2, name: "Pete" },
  { id: 3, name: "Mary" },
  { id: 4, name: "John" },
];

alert(users.findIndex((item) => item.name == "John")); //寻找第一个John的索引
alert(users.findLastIndex((item) => item.name == "John")); //寻找最后一个John的索引
```

## 在对象数组中查找符合条件的所有对象

### arr.filter(func,[thisArg])

```javascript
let results = arr.filter(function (item, index, array) {
  //如果返回true，item被push到results，继续迭代
  //没有符合条件的对象，返回空数组
});
```

```javascript
let users = [
  { id: 1, name: "John" },
  { id: 2, name: "Pete" },
  { id: 3, name: "Mary" },
];
let someUsers = users.filter((item) => item.id < 3);
alert(someUsers.length); //2
```

## 转换数组

### arr.map(func,[thisArg])

- 遍历元素并调用 func，返回结果数组

```javascript
let result = arr.map(function (item, index, array) {
  //返回新值
});
```

```javascript
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map((item) => item.length);
alert(lengths); //5,7,6
```

### arr.sort(func)

- 原位排序，会修改原数组 arr
- 返回排序后的数组
- 默认按字符串排序

```javascript
let arr = [1, 2, 15];
arr.sort();
alert(arr); //1,15,2 默认按字符串排序
```

- 自定义比较算法：func
  - a > b,返回正数
  - a == b,返回 0
  - a < b,返回负数

```javascript
function compare(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [1, 2, 15];
arr.sort(compare);
alert(arr); //1,2,15

//箭头函数简写
arr.sort((a, b) => a - b);

//字符串比较
let countries = ["Österreich", "Andorra", "Vietnam"];
countries.sort((a, b) => a.localeCompare(b));
```

### arr.reverse()

- 原位倒置，会修改原数组 arr
- 返回倒置后的数组

```javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert(arr); //5,4,3,2,1
```

## 数组与有分隔符字符串的转换

### arr.join(glue)

- 返回由 glue 分隔的 arr 元素组成的字符串

```javascript
let arr = ["Biobo", "Gandalf", "Nazgul"];
let str = arr.join(";");
alert(str); //Biobo;Gandalf;Nazgul
```

### str.split(delim,[count])

- 通过 delim 分隔符，将 str 分割到数组中
- count 指定数组的长度，忽略额外的元素
- 可以用""把单个字符串拆分成字符数组

```javascript
let names = "Bilbo,Gandalf,Nazgul";
let arr = names.split(",");
for (let name of arr) {
  alert(`A message to ${name}.`);
}

let arr = names.split(",", 2);
alert(arr); //Bilbo,Gandalf

let str = "test";
alert(str.split("")); //t,e,s,t
```

## 数组的聚合计算

### arr.reduce(func,[initial])

- **从左往右**遍历元素并调用 func，并将返回值传递到下一次迭代，返回最有一次迭代的结果
- 省略 initial 则取 arr[0]，从第二个元素开始迭代

```javascript
/*
accumulator：上一次迭代的返回值，默认值：initial
item：元素
index：元素索引
array：元素所在的数组
*/
let value = arr.reduce(
  function (accumulator, item, index, array) {
    //...
  },
  [initial]
);
```

```javascript
//数组累加器
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); //15

//省略initial，取initial=arr[0],从arr[1]开始迭代
let result = arr.reduce((sum, current) => sum + current);

//arr为空，initial必须有值，reduce返回inital
let arr = [];
let result = arr.reduce((sum, current) => sum + current, 0);
```

### arr.reduceRight(func,[initial])

- **从右往左**遍历元素并调用 func，并将返回值传递到下一次迭代，返回最有一次迭代的结果
- 省略 initial 则取 arr[0]，从第二个元素开始迭代

## 区分常规对象与数组

### Array.isArray(value)

- typeof 不能区分常规对象与数组
- Array.isArray(value)：value 是数组返回 true，否则返回 false

```javascript
alert(typeof {}); //object
alert(typeof []); //object

alert(Array.isArray([])); //true
alert(Array.isArray({})); //false
```

## 传递函数中的 this：thisArg 可选参数

```javascrip
arr.find(func,[thisArg]);
arr.filter(func,[thisArg]);
arr.map(func,[thisArg]);
```

- thisArg 参数的值在 func 中变为 this

```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age <= this.maxAge;
  },
};
let users = [{ age: 16 }, { age: 20 }, { age: 23 }, { age: 30 }];
let soldiers = users.filter(army.canJoin, army); //thisArg:army
let soldiers = users.filter((user) => army.canJoin(user)); //等效
//let soldiers=users.filter(army.canJoin) 报错，因为this等于undefined
```

## 其他常用函数

### arr.some(func)

### arr.every(func)

### arr.fill(value,start,end)

### arr.copyWithin(target,start,end)

### arr.flat(depth)

### arr.flatMap(func)

### Array.of(element0,...,elementN)

## 可迭代对象

- 数组的泛化，可以使用 for...of 语法

### Symbol.iterator

```javascript
let range = { from: 1, to: 5 };
range[Symbol.iterator] = function () {
  return {
    current: this.from,
    last: this.to,
    next() {
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    },
  };
};
for (let num of range) {
  alert(num); //1,2,3,4,5
}
```
