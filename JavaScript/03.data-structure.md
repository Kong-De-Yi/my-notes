# 原始类型的方法

## 需求：使用方法对原始类型执行操作

- 解决方案：对象包装器（String、Number、Boolean、Symbol、Bigint）
- 实现原理：访问原始值的属性时，创建对象包装器对象，访问结束就销毁

```javascript
let str = "hello";
alert(str.toUpperCase()); //HELLO

let n = 1.23456;
alert(n.toFixed(2)); //1.23
```

- 构造器 String/Number/Boolean 仅供内部使用

```javascript
alert(typeof 0); //"number"
alert(typeof new Number(0)); //"object"

let zero = new Number(0);
if (zero) {
  //zero是对象，始终为true
  alert("zero is truthy?!?");
}
```

- 调用不带"new"的 String/Number/Boolean 有效

```javascript
let num = Number("123"); //将字符串转换为数字
```

- null 和 undefined 没有对象包装器，也没有任何方法

# 数字类型

- Number：双精度浮点数（64 位 IEEE-754 格式），范围 ±($2^{53}$-1)
- Bigint：任意长度的整数

## 数字的更多写法

```javascript
let billion = 1000000000;
let billion = 1_000_000_000; //更具可读性的写法，_会被javascript引擎忽略

//e后面的正数表示乘以1后面跟着指定数量的0的数字
1e3 === 1 * 1000; //e3表示*1000
1.23e6 === 1.23 * 1000000; //e6表示*1000000

//e后面的负数表示除以1后面跟着指定数量的0的数字
1e-3 === 1 / 1000; //e-3表示/1000
1.23e-6 === 1.23 / 1000000; //e-6表示/1000000
1234e-2 === 1234 / 100; //e-2表示/100
```

## 不同的进制

- 十六进制：`0xff`、`0xFF`(255)
- 二进制：`0b11111111`(255)
- 八进制：`0o377`(255)
- `toString(base)`：
  - 返回 base 进制中的字符串表示形式
  - base 取值范围 2-36，默认 10

```javascript
let num = 255;
alert(num.toString(16)); //ff
alert(num.toString(2)); //11111111
```

- 使用两个点来调用方法(或者括号)：
  `let num = 123456789..toString(36); //'21i3v9'`
  `let num = (123456789).toString(36); //'21i3v9'`

## 数字的舍入

- 舍入到整数
  - Math.floor：向下舍入，3.1 —> 3,-1.1 —> -2
  - Math.ceil：向上输入，3.1 —> 4,-1.1 —> -1
  - Math.round：向最接近的整数舍入，3.1 —> 3,3.6 —> 4，3.5 —> 4
  - Math.trunc：截断取整，3.1 —> 3,-1.1 —> -1
- 舍入到小数点后 n 位
  - 乘除法
  - toFixed(n)：将数字舍入到小数点后 n 位，并返回字符串形式，向最接近的值输入，类似 Math.round

```javascript
let num = 1.23456;
alert(Math.round(num * 100) / 100); //1.23456—>123.456—>123—>1.23

let num = 12.36;
alert(num.toFixed(1)); //"12.4"
alert(num.toFixed(5)); //"12.36000"，在末尾添加0
```

## 不精确的计算

- 64 位格式存储 —> 数据溢出`alert(1e500);//Infinity`
- 二进制下无限循环小数 —> 精度损失

```javascript
alert(0.1 + 0.2 == 0.3); //fasle
alert(0.1 + 0.2); //0.30000000000000004
alert((0.1).toFixed(20)); //0.10000000000000000555
```

- 解决办法：`toFixed(n)`,返回 string

```javascript
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); //"0.30"
alert(+sum.toFixed(2)); //0.3
```

- 乘除法可以减少误差，不能完全消除误差

## 测试：isFinite 和 isNaN

- `isNaN(value)`：将 value 转化为数字后测试是否为 NaN（===NaN 始终返回 false，无法测试）

```javascript
alert(isNaN(NaN)); //true
alert(isNaN("str")); //true
alert(NaN === NaN); //false
```

- `isFinite(value)`：将 value 转化为数字后测试是否为$ \pm $ Infinity 或 NaN，否则返回 true

```javascript
alert(isFinite("15")); //true
alert(isFinite("str")); //false,转化结果为NaN
alert(isFinite(Infinity)); //fasle

//验证输入值是否为常规数字
let num = +prompt("Enter a number", "");
alert(isFinite(num)); //
```

- `Object.is(a,b)`：类似 ===，边缘情况更可靠
  - `Object.is(NaN,NaN) === true`
  - `Object.is(+0,-0) === false`
  - 其他情况`Object.is(a,b)`与`a === b`相同

## 智能提取数字（parseInt 和 parseFloat）

- 从字符串中读取数字，直到无法读取为止

```javascript
alert(parseInt("100px")); //100
alert(parseInt("12.3")); //12，只返回整数

alert(parseFloat("12.5em")); //12.5
alert(parseFloat("12.3.4")); //12.3,第二个点处停止了读取

alert(parseInt("a123")); //NaN,第一个符号停止了读取
```

- `parseInt(str,[radix])`:radix 可选，指定数制解析多进制下的字符串

```javascript
alert(parseInt("0xff", 16)); //255
alert(parseInt("ff"), 16); //255，没有0x依然有效
alert(parseInt("2n9c", 36)); //123456
```

## 内建对象：Math

- `Math.random()`:返回[0.0,1.0)范围的随机数
- `Math.max(arg1,arg2,...,argN)`和`Math.min(arg1,arg2,...,argN)`：返回最大值和最小值
- `Math.pow(n,power)`：返回 n 的 power 次幂

# 字符串

- 单个字符没有特有的类型
- 内部编码：UTF-16

## 转义字符

- \n —> 换行
- \\' —> 单引号
- \\\" —> 双引号
- \\\ —> 反斜线
- \xXX —> 十六进制 Unicode 码的对应字符，"\x7A" —> "z"
- \uXXXX —> 十六进制 UTF-16 编码的对应 Unicode 字符，"\u00A9" —> "©"
- \u{X...XXX} —> 十六进制 UTF-32 编码的对应 Unicode 字符
- 只有与外部闭合引号相同的引号才需要转义

```javascript
let str = `I'm the Walrus!`; //I'm the Walrus!
let str = "I'm the Walrus!"; //I'm the Walrus!
let str = `The backslash：\\`; //The backslash：\
```

## 字符串长度：属性`length`

```javascript
alert(`My\n`.length); //3
```

## 访问字符串中的字符

- 第一个字符位置：0
- `str[pos]`：返回 pos 位置的字符，没有返回 undefined
- `str.charAt(pos)`：返回 pos 位置的字符，没有返回空字符串

```javascript
let str = `Hello`;
alert(str[0]); //H
alert(str.charAt(0)); //H
alert(str[str.length - 1]); //返回最后一个字符
alert(str[1000]); //undefined
alart(str.charAt(1000)); //""
```

- 遍历字符：for...of

```javascript
for (let char of "Hello") {
  alert(char); //H,e,l,l,o
}
```

## 字符串是不可变的

```javascript
let str = "Hi";
str[0] = "h"; //error

str = "h" + str[1]; //替换字符串
```

## 改变大小写

- `toUpperCase()`：返回大写形式
- `toLowerCase()`：返回小写形式

## 查找子字符串

### str.indexOf(substr,[pos])

- 从 pos 位置（可选）**向右**查找子字符串 substr**第一次**出现在 str 中的位置（区分大小写）
- 返回查找到的位置，没有返回 -1

```javascript
let str = "Widget with id";
alert(str.indexOf("Widget")); //0
alert(str.indexOf("widget"));
-1; //没有找到，大小写敏感
alert(str.indexOf("id")); //1
alert(str.indexOf("id", 2)); //12，从位置2开始检索

//检索所有匹配的位置
let str = "As sly as a fox,as strong as an ox";
let target = "as";
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert(pos);
}
```

- 不方便的地方

```javascript
let str = "Widget with id";
//不会工作，indexOf返回0，布尔转换为false
if (str.indexOf("Widget")) {
  alert("We found it");
}
//正确写法
if (str.indexOf("Wigdet") != -1) {
  alert("We found it");
}
```

- 使用按位（bitwise）NOT 技巧
  - 原理 ~n == - (n+1) 即 ~ (-1) == - 0
  - `if(str.indexOf(...) != -1)`可简写为`if(~str.indexOf(...))`

### str.lastIndexOf(substr,[pos])

- 从 pos 位置（可选）**向左**查找子字符串 substr**最后一次**出现在 str 中的位置（区分大小写）
- 返回查找到的位置，没有返回 -1

### str.includes(substr,[pos])

- 从 pos 位置（可选）查找确认是否包含子字符串 substr（区分大小写）
- 返回 true/false

### str.startsWith(substr)与 str.endsWith(substr)

- 确认是否以子字符串 substr 开始（结尾）
- 返回 true/false

## 获取子字符串

### str.slice(start,[end])

- 返回字符串从 start 到 end（不含）的部分
- end 可选，无则截取到字符串末尾
- start/end 可为负数，从末尾开始计算
- start 必须小于 end，否则返回空字符串

```javascript
let str = "stringify";
alert(str.slice(-4, -1)); //'gif',从右边第4个位置开始到右边的第1个位置结束
```

### str.substring(start,[end])

- 返回字符串从 start 到 end（不含）的部分
- end 可选，无则截取到字符串末尾
- 不支持负参数，被视为 0
- start 可以大于 end

```javascript
let str = "stringify";
alert(str.substring(2, 6)); //"ring"
alert(str.substring(6, 2)); //"ring"

alert(str.slice(2, 6)); //"ring"
alert(str.slice(6, 2)); //""(空字符串)
```

### str.substr(start,[length])

- 返回字符串从 start 开始 length 长度的部分
- length 可选，无则截取到字符串末尾
- start 可为负数，从末尾开始计算

```javascript
let str = "stringify";
alert(str.substr(-4, 2)); //"gi",从右边第4个位置开始取2个字符
```

## 比较字符串

- 通过 UTF-16 编码进行比较，编码越大字符越大

### str.codePointAt(pos)

- 返回在 pos 位置的字符 UTF-16 编码

### String.fromCodePoint(code)

- 通过 UTF-16 编码 code 创建字符

```javascript
alert("z".codePointAt(0)); //122
alert("Z".codePointAt(0)); //90
alert(String.fromCodePoint(90)); //Z
alert("\u005a"); //Z
```

### 正确比较：str.localeCompare(str2)

- str 在 str2 前，返回负数
- str 在 str2 后，返回正数
- 位置相同，返回 0

## 常用字符串方法：

- `str.trim()`：删除字符串前后的空格
- `str.repeat(n)`：重复字符串 n 次

# 数组

## 用途：存储有序的元素集合

- 本质是一种特殊的对象（通过引用复制）
- 元素可以是任何类型

## 数组的创建（声明）

```javascript
//创建空数组
let arr = new Array();
let arr = [];

//创建指定长度的空数组
let arr = new Array(2);
alert(arr[0]); //undefined,没有元素
alert(arr.length); //2

//添加初始元素
let fruits = new Array("Apple", "Pear", "etc");
let fruits = ["Apple", "Orange", "Plum"];
alert(fruits); //Apple,Orange,Plum

//混合类型元素
let arr = [
  "Apple",
  { name: "John" },
  true,
  function () {
    alert("Hello");
  },
];
alert(arr[1].name); //John
arr[3](); //Hello
```

- 清空数组：`arr.length = 0;`（修改 length 属性）
- 最后一个元素以逗号结尾，方便添加，删除和移动元素

## 元素的访问

- 数组元素从 0 开始编号
- 使用方括号索引获取

```javascript
let fruits = ["Apple", "Orange", "Plum"];
alert(fruits[0]); //Apple
fruits[2] = "Pear"; //替换元素
fruits[3] = "Lemon"; //直接赋值添加元素
```

## 数组的长度：length 属性

```javascript
let fruits = ["Apple", "Orange", "Plum"];
alert(fruits.length); //3
```

## 获取最后一个元素：arr\.at(i)

- 索引方式不支持负向索引，arr[-1] —> undefined
- 常规方法：使用 length 属性
- 简便方法：使用 at(-1)

```javascript
let fruits = ["Apple", "Orange", "Plum"];
alert(fruits[fruits.length - 1]); //Plum
alert(fruits.at(-1)); //Plum
```

- 原理：i >= 0,与 arr[i]等效，i < 0,从数组尾部往前数

## 数组支持双端队列（deque）

### 队列（queue）：先进先出 FIFO（First-In-First-Out)

### 栈（stack）：后进先出 LIFO（Last-In-First-Out）

- push：在数组末端添加 n 个元素
- pop：删除并返回数组末端最后一个元素
- unshift：在数组首端添加 n 个元素
- shift：删除并返回数组首端第一个元素

```javascript
let fruits = ["Apple", "Orange"];

fruits.push("Pear");
alert(fruits); //Apple,Orange,Pear

alert(fruits.shift()); //Apple
alert(fruits); //Orange,Pear

fruits.unshift("Apple");
alert(fruits); //Apple,Orange,Pear

alert(fruits.pop()); //Pear
alert(fruits); //Apple,Orange

let fruits = ["Apple"];
fruits.push("Orange", "Pear");
fruits.unshift("Pineapple", "Lemon");
alert(fruits); //Pineapple,Lemon,Apple,Orange,Peach
```

- 末端操作（push/pop）比首端操作（shift/unshift)效率高（首端操作需要移动所有的元素）

## 以"有序集合"的方式使用数组

- 不要用常规对象方式使用，否则会失去 Javascript 引擎的优化
  - 不要添加非数字属性
  - 不要制造空洞
  - 不要倒序填充数组

```javascript
let arr = [];
//添加非数字属性
arr.test = 5;
//制造空洞，中间什么也没有
arr[0] = 0;
arr[1000] = 1000;
//倒序填充
arr[1000] = 1000;
arr[999] = 999;
```

## 遍历数组中的元素

- 常规 for 循环：同时获取索引和元素
- 专用 for...of：只能获取元素
- 对象方式：for...in：有潜在问题，会遍历**所有属性**
- arr.forEach(func)：为每个元素运行一次函数（忽略返回值）

```javascript
/*
item：元素
index：元素索引
array：元素所在的数组
*/
arr.forEach(function (item, index, array) {
  //do something with item
});
```

```javascript
let arr = ["Apple", "Orange", "Pear"];
//常规for循环
for (let i = 0; i < arr.length; i++) {
  alert(arr[i]);
}
//数组专用方式
for (let item of arr) {
  alert(item);
}

//对每个元素调用alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) =>
  alert(`${item} is at index ${index} in ${array}`)
);
```

## 属性 length 的本质

- 最大的索引值 +1（不是元素的总个数）
- 可以修改，减小 length 会截断数组（不可逆）

```javascript
let arr = [];
arr[123] = "Apple";
alert(arr.length); //124

let arr = [1, 2, 3, 4, 5];
arr.length = 2;
alert(arr); //1,2

arr.length = 5;
alert(arr[3]); //undefined,数据丢失
```

## 多维数组（数组中的数组）

```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];
alert(matrix[1][1]); //5
```

## 数组的 toString()

- 返回逗号分隔的元素列表
- 数组没有 Symbol.toPrimitive 和 valueOf

```javascript
let arr = [1, 2, 3];
alert(arr); //1,2,3
alert(String(arr) === "1,2,3"); //true

alert([] + 1); //"1"
alert([1] + 1); //"11"
alert([1, 2] + 1); //"1,21"
```

## 比较数组

- 不要用 == 比较，数组按对象方式比较
- 遍历元素逐项比较

```javascript
alert([] == []); //false
alert([0] == [0]); //false

let arr1 = [1, 2, 3];
let arr2 = arr1;
alert(arr1 == arr2); //true

alert(0 == []); //true,[] —> "" —> 0
alert("0" == []); //false,[] —> ""
```

## 自由添加/移除数组元素

- delete 方法的潜在问题（不会移动剩下的元素，length 不变）

```javascript
let arr = ["I", "go", "home"];
delete arr[1];
alert(arr[1]); //undefined
alert(arr); //I,,home
alert(arr.length); //3
```

### arr.splice(start,[deleteCount,elem1,...,elemN])：添加/删除/插入

- 从 start 位置开始删除 deleteCount 个元素，并用 elem1,...elemN 替换它们
- 支持负向索引
- 返回删除元素组成的数组

```javascript
let arr = ["I", "sutdy", "JavaScript"];

arr.splice(1, 1); //从索引1开始删除1个元素
alert(arr); //I,JavaScript

let arr = ["I", "sutdy", "JavaScript"];
arr.splice(1); //从索引1开始删除后面所有的元素
alert(arr); //I

//删除元素并用新元素替换
let arr = ["I", "study", "JavaScript", "right", "now"];
let removed = arr.splice(1, 3, "Let's", "dance");
alert(removed); //study,JavaScript，right
alert(arr); //I,Let's，dance,now

//插入新元素(在start之前插入)
let arr = ["I", "study", "JavaScript"];
arr.splice(1, 0, "complex", "language");
alert(arr); //I,complex,language,study,JavaScript

//负向索引
let arr = [1, 2, 5];
arr.splice(-1, 0, 3, 4);
alert(arr); //1,2,3,4,5
```

### arr.slice([start],[end])：获取（子）数组副本

- 创建并返回新数组，复制[start,end)范围内的元素到新数组
- 支持负向索引
- 不影响原始数组

```javascript
let arr = ["t", "e", "s", "t"];
alert(arr.slice(1, 3)); //e,s
//负向索引
alert(arr.slice(-2)); //s,t
//创建数组副本
alert(arr.slice()); //t,e,s,t
```

### arr.concat(arg1,arg2...)：合并数组和元素

- 返回由 arr 中元素和参数解构后元素组成的新数组
- 只会解构具有 Symbol.isConcatSpreadable 的参数

```javascript
let arr = [1, 2];
alert(arr.concat([3, 4])); //1,2,3,4
alert(arr.concat([3, 4], [5, 6], 7, 8)); //1,2,3,4,5,6,7,8

let arrayLike = {
  0: "somethong",
  length: 1,
};
alert(arr.concat(arrayLike)); //1,2,[object Object]

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadble]: true,
  length: 2,
};
alert(arr.concat(arrayLike)); //1,2,something,else
```

## 查找元素

### arr.indexOf(item,[from])

- 从 from 位置（可选）开始**向右**查找 item,找到立即返回索引，否则返回-1
- 使用严格相等 === 进行比较
- 无法正确处理 NaN

### arr.includes(item,[from])

- 从 from 位置（可选）开始查找 item，找到返回 true，否则返回 false
- 使用严格相等 === 进行比较
- 可以正确处理 NaN

### arr.lastIndexOf(item,[from])

- 从 from 位置（可选）开始**向左**查找 item,找到立即返回索引，否则返回-1

```javascript
let arr = [1, 0, false];
alert(arr.indexOf(0)); //1
alert(arr.indexOf(false)); //2
alert(arr.indexOf(null)); //-1

alert(arr.includes(1)); //true

let fruits = ["Apple", "Orange", "Apple"];
alert(fruits.indexOf("Apple")); //0
alert(fruits.lastIndexOf("Apple")); //2

const arr = [NaN];
alert(arr.indexOf(NaN)); //-1,错误，应该是0
alert(arr.includes(NaN)); //true
```

## 在对象数组中查找符合条件的单个对象

### arr.find(func,[thisArg])

```javascript
/*
item：元素
index：元素索引
array：元素所在数组
*/
let result = arr.find(function (item, index, array) {
  //如果返回true，则返回item并停止迭代
  //如果返回false，则返回undefined
});
```

- **从左往右**遍历元素并调用 func,返回 true 则停止搜索并返回 item，没有则返回 undefined

```javascript
//找到 id == 1 的用户
let users = [
  { id: 1, name: "John" },
  { id: 2, name: "Pete" },
  { id: 3, name: "Mary" },
];

let user = users.find((item) => item.id == 1);
alert(user.name);
```

### arr.findIndex(func)

- **从左往右**遍历元素并调用 func,返回 true 则停止搜索并返回 index，没有则返回 -1

### arr.findLastIndex(func)

- **从右往左**遍历元素并调用 func,返回 true 则停止搜索并返回 index，没有则返回 -1

```javascript
let users = [
  { id: 1, name: "John" },
  { id: 2, name: "Pete" },
  { id: 3, name: "Mary" },
  { id: 4, name: "John" },
];

alert(users.findIndex((item) => item.name == "John")); //寻找第一个John的索引
alert(users.findLastIndex((item) => item.name == "John")); //寻找最后一个John的索引
```

## 在对象数组中查找符合条件的所有对象

### arr.filter(func,[thisArg])

```javascript
let results = arr.filter(function (item, index, array) {
  //如果返回true，item被push到results，继续迭代
  //没有符合条件的对象，返回空数组
});
```

```javascript
let users = [
  { id: 1, name: "John" },
  { id: 2, name: "Pete" },
  { id: 3, name: "Mary" },
];
let someUsers = users.filter((item) => item.id < 3);
alert(someUsers.length); //2
```

## 转换数组

### arr.map(func,[thisArg])

- 遍历元素并调用 func，返回结果数组

```javascript
let result = arr.map(function (item, index, array) {
  //返回新值
});
```

```javascript
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map((item) => item.length);
alert(lengths); //5,7,6
```

### arr.sort(func)

- 原位排序，会修改原数组 arr
- 返回排序后的数组
- 默认按字符串排序

```javascript
let arr = [1, 2, 15];
arr.sort();
alert(arr); //1,15,2 默认按字符串排序
```

- 自定义比较算法：func
  - a > b,返回正数
  - a == b,返回 0
  - a < b,返回负数

```javascript
function compare(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [1, 2, 15];
arr.sort(compare);
alert(arr); //1,2,15

//箭头函数简写
arr.sort((a, b) => a - b);

//字符串比较
let countries = ["Österreich", "Andorra", "Vietnam"];
countries.sort((a, b) => a.localeCompare(b));
```

### arr.reverse()

- 原位倒置，会修改原数组 arr
- 返回倒置后的数组

```javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert(arr); //5,4,3,2,1
```

## 数组与有分隔符字符串的转换

### arr.join(glue)

- 返回由 glue 分隔的 arr 元素组成的字符串

```javascript
let arr = ["Biobo", "Gandalf", "Nazgul"];
let str = arr.join(";");
alert(str); //Biobo;Gandalf;Nazgul
```

### str.split(delim,[count])

- 通过 delim 分隔符，将 str 分割到数组中
- count 指定数组的长度，忽略额外的元素
- 可以用""把单个字符串拆分成字符数组

```javascript
let names = "Bilbo,Gandalf,Nazgul";
let arr = names.split(",");
for (let name of arr) {
  alert(`A message to ${name}.`);
}

let arr = names.split(",", 2);
alert(arr); //Bilbo,Gandalf

let str = "test";
alert(str.split("")); //t,e,s,t
```

## 数组的聚合计算

### arr.reduce(func,[initial])

- **从左往右**遍历元素并调用 func，并将返回值传递到下一次迭代，返回最有一次迭代的结果
- 省略 initial 则取 arr[0]，从第二个元素开始迭代

```javascript
/*
accumulator：上一次迭代的返回值，默认值：initial
item：元素
index：元素索引
array：元素所在的数组
*/
let value = arr.reduce(
  function (accumulator, item, index, array) {
    //...
  },
  [initial]
);
```

```javascript
//数组累加器
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); //15

//省略initial，取initial=arr[0],从arr[1]开始迭代
let result = arr.reduce((sum, current) => sum + current);

//arr为空，initial必须有值，reduce返回inital
let arr = [];
let result = arr.reduce((sum, current) => sum + current, 0);
```

### arr.reduceRight(func,[initial])

- **从右往左**遍历元素并调用 func，并将返回值传递到下一次迭代，返回最有一次迭代的结果
- 省略 initial 则取 arr[0]，从第二个元素开始迭代

## 区分常规对象与数组

### Array.isArray(value)

- typeof 不能区分常规对象与数组
- Array.isArray(value)：value 是数组返回 true，否则返回 false

```javascript
alert(typeof {}); //object
alert(typeof []); //object

alert(Array.isArray([])); //true
alert(Array.isArray({})); //false
```

## 传递函数中的 this：thisArg 可选参数

```javascrip
arr.find(func,[thisArg]);
arr.filter(func,[thisArg]);
arr.map(func,[thisArg]);
```

- thisArg 参数的值在 func 中变为 this

```javascript
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age <= this.maxAge;
  },
};
let users = [{ age: 16 }, { age: 20 }, { age: 23 }, { age: 30 }];
let soldiers = users.filter(army.canJoin, army); //thisArg:army
let soldiers = users.filter((user) => army.canJoin(user)); //等效
//let soldiers=users.filter(army.canJoin) 报错，因为this等于undefined
```

## 其他常用函数

### arr.some(func)

### arr.every(func)

### arr.fill(value,start,end)

### arr.copyWithin(target,start,end)

### arr.flat(depth)

### arr.flatMap(func)

### Array.of(element0,...,elementN)

# 可迭代对象

- 内建可迭代对象：数组和字符串
- 数组的泛化，可以使用 for...of 语法

## Symbol.iterator

- 迭代器对象（iterator）：实现了 next()方法的对象
- 运行过程
  1. for...of 调用 Symbol.iterator 方法获取迭代器对象
  2. for...of 循环调用迭代器对象的 next()方法
  3. next()方法返回{done:Boolean,value:any},done 为 ture 表示循环结束，否则 value
     就是下一个值
- 核心：关注点分离，迭代器对象与迭代对象是分开的
- 好处：每次调用 Symbol.iterator 方法会获取一个独立的迭代器对象

```javascript
let range = { from: 1, to: 5 };
range[Symbol.iterator] = function () {
  return {
    current: this.from,
    last: this.to,
    next() {
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    },
  };
};
for (let num of range) {
  alert(num); //1,2,3,4,5
}
```

## 合并迭代对象与迭代器

- 缺点：不能同时运行两个 for...of 循环，因为只有一个迭代器，共享迭代状态

```javascript
let range = {
  from: 1,
  to: 5,
  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },
  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  },
};
for (let num of range) {
  alert(num);
}
```

## 无穷迭代器

- 在 for...of 中用 break 停止迭代

```javascript
let range = {
  from: 1,
  to: Infinity, //next()会返回越来越多的值
};
```

## 显式调用迭代器

```javascript
let str = "Hello";
//与for...of做相同的事
//for(let char of str){alert(char)}
let iterator = str[Symbol.iterator];
while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value);
}
```

## 可迭代（iterable）和类数组（array-like）

- 可迭代对象：实现了 Symbol.iterator 方法的对象
- 类数组对象：有索引和 length 属性的对象

```javascript
//有索引和length属性 —> 类数组对象
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2,
};
for (let item of arrayLike) {
} //Error：no Symbol.iterator
```

## Array.from(obj,[mapFn],[thisArg])：将可迭代和类数组对象转换为数组

- 创建新数组，将 obj 的所有元素复制进来
- mapFn：转换函数
- thisArg：this 的值

```javascript
//将类数组对象转化为数组
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2,
};
let arr = Array.from(arrayLike);
alert(arr.pop()); //World

//将可迭代对象转化为数组
let arr = Array.from(range);
alert(arr); //1,2,3,4,5

//使用转化函数
let arr = Array.from(range, (num) => num * num);
alert(arr); //1,4,9,16,25
```

- 字符串迭代器可以识别 UTF-16 扩展字符

# 映射（Map）

- key:value 的集合，key 和 value 均可为任何类型
- key 不会被转换成 string
- 使用 SameValueZero 算法比较键，类似严格等于 ===（区别：NaN 可作为 key，NaN 被看成等于 NaN）
- 不要用 map[key] 访问 Map（map 会被当成常规对象，仅支持 string/symbol 键)

## 常用方法和属性

- new Map([iterable])：创建 map（可以用键值对数组或其他可迭代对象初始化）
- map.set(key,value)：存储键值对，返回 map 自身
- map.get(key)：根据 key 返回 value，不存在则返回 undefined
- map.has(key)：查询 key 是否存在，返回 true/false
- map.delete(key)：删除键值对，key 存在返回 true，否则返回 false
- map.clear()：清空 map
- map.size：元素个数

```javascript
let map = new Map();
map.set("1", "str1"); //字符串key
map.set(1, "num1"); //数字key
map.set(true, "bool1"); //布尔key

let john = { name: "John" };
let visitsCountMap = new Map();
visitsCountMap.set(john, 123); //对象key

//使用可迭代对象（数组）初始化
let map = new Map([
  ["1", "str1"],
  [1, "num1"],
  [true, "bool1"],
]);
alert(map.get("1")); //str1

//常规对象不支持对象key，会被转换为"[object Object]"
let john = { name: "John" };
let ben = { name: "Ben" };
let visitsCountObj = {};
visitsCountObj[ben] = 234;
visitsCountObj[john] = 123;
alert(visitsCountObj["[object Object]"]); //123
```

## 链式调用

- map.set(key,value)返回 map 本身

```javascript
map.set("1", "str1").set(1, "num1").set(true, "bool1");
```

## Map 迭代

- map.keys()：返回所有 key 的可迭代对象
- map.values()：返回所有 value 的可迭代对象
- map.entries()：返回所有[key,value]的可迭代对象（for...of 默认使用）
- map.forEach(func)：对每个[key,value]运行 func(value,key,map) 函数
- 迭代顺序与插入顺序相同

```javascript
let recipeMap = new Map([
  ["cucumber", 500],
  ["tomatoes", 350],
  ["onion", 50],
]);

//遍历所有key
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); //cucumber,tomatoes,onion
}
//遍历所有value
for (let amount of recipeMap.values()) {
  alert(amount); //500,350,50
}
//遍历所有实体[key,value]
//等效for(let entry of recipeMap.entries())
for (let entry of recipeMap) {
  alert(entry); //cucumber,500(and so on)
}
//遍历并执行函数
recipeMap.forEach((value, key, map) => alert(`${key}：${value}`)); //cucumber：500 etc
```

## Map 与常规对象的转换

### 常规对象 —> Map：Object.entries(obj)

- 返回对象的 [key,value] 数组（key 始终是 string）

```javascript
let obj = {
  name: "John",
  age: 30,
};
//Object.entries(obj)返回：[["name","John"],["age",30]]
let map = new Map(Object.entries(obj));
alert(map.get("name")); //John
```

### Map —> 常规对象：Object.fromEntries(obj)

- 根据 [key,value] 数组创建对象
- obj 不一定是数组，可以是任意可迭代对象（如 Map）

```javascript
//从键值对数组创建
let prices = Object.fromEntries([
  ["banana", 1],
  ["orange", 2],
  ["meat", 4],
]);
//现在prices是{banana:1,orange:2,meat:4}
alert(prices.orange); //2
//从Map创建
let map = new Map();
map.set("banana", 1);
map.set("orange", 2);
map.set("meat", 4);

//等效let obj=Object.fromEntries(map)
let obj = Object.fromEntries(map.entries());
//现在prices是{banana:1,orange:2,meat:4}
alert(obj.orange); //2
```

# 集合（Set）

- 没有重复值的集合

## 常用方法和属性

- new Set([iterable])：创建 set(可以用可迭代对象初始化)
- set.add(value)：添加值并返回 set 本身（value 会去重）
- set.delete(value)：删除值，若 value 存在返回 true，否则返回 false
- set.has(value)：值存在返回 true，否则返回 false
- set.clear()：清空 set
- set.size：返回元素个数

```javascript
let set = new Set();
let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };
set.add(john).add(pete).add(mary).add(john).add(mary);
alert(set.size); //3,set只保留不重复的值
for (let user of set) {
  alert(user.name); //John Pete Mary
}
```

## Set 迭代

- set.keys()：返回所有 value 的可迭代对象（for...of 默认使用）
- set.values()：返回所有 value 的可迭代对象
- set.entries()：返回所有[value,value]的可迭代对象
- set.forEach(func)：对每个[value,value]运行 func(value,valueAgain,set) 函数
- 迭代顺序与插入顺序相同

```javascript
let set = new Set(["oranges", "apples", "bananas"]);
for (let value of set) alert(value);
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```

# 弱映射和弱集合（WeakMap and WeakSet)

- 通常对象、数组存在时，子元素（对象属性、数组元素）被认为是可达的
- 对象作为 Map 的 key，只要 Map 存在，对象就不会被垃圾回收

```javascript
let john = { name: "John" };
let array = [john];
//对象{name:"John"}不会被垃圾回收，仍然可以通过array[0]获取到
john = null;

let john = { name: "John" };
let map = new Map();
map.set(john, "...");
//对象{name:"John"}不会被垃圾回收，仍然可以通过map.keys()获取到
john = null;
```

## 弱映射（WeakMap）

- key 必须是对象（key object），不能是原始值
- 对 obj 是弱引用，不会阻止 key object 的垃圾回收，当 key object 没有其他引用时，会从内存和 weakMap 中清除（包括 value）
- 不支持迭代，没有 keys()、values()、entries()方法、size 属性（因为回收时机不确定）

```javascript
let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, "ok");
weakMap.set("test", "Whoops"); //Error,原始值不能作为WeakMap的键

let john = { name: "John" };
let weakMap = new WeakMap();
weakMap.set(john, "...");
//对象{name:"John"}会被垃圾回收
john = null;
```

### 常用方法

- get(obj)
- set(obj,value)
- delete(obj)
- has(obj)

### 应用场景

- 存储对象的额外数据

```javascript
let visitsCountMap = new WeakMap();
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  vistitsCountMap.set(user, count++);
}
let john = { name: "John" };
countUser(john);
//visitsCountMap中的key和value也会自动清除
john = null;
```

- 缓存

```javascript
let cache = new WeakMap();
function process(obj) {
  if (!cache.has(obj)) {
    //let result=...obj 对obj进行计算
    cache.set(obj, result);
  }
  return cache.get(obj);
}
let obj = { name: "John" };
let result1 = process(obj);
let result2 = process(obj); //使用缓存
//cacha中的key和value也会自动清除
obj = null;
```

## 弱集合（WeakSet）

- 只能添加对象，不能是原始值
- 对 obj 是弱引用，不会阻止 object 的垃圾回收，当 object 没有其他引用时，会从内存和 weakSet 中清除
- 不支持迭代，没有 keys()、values()、entries()方法、size 属性（因为回收时机不确定）

### 常用方法

- add(obj)
- has(obj)
- delete(obj)

### 应用场景

- 记录"是/否"

```javascript
let visitedSet = new WeakSet();
let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

alert(visitedSet.has(john));
//john会自动从visitedSet中清除
john = null;
```

# 常规对象的迭代

- Object.keys(obj)：返回对象所有属性键组成的数组
- Object.values(obj)：返回对象所有属性值组成的数组
- Object.entries(obj)：返回对象所有[key,value]组成的数组
- 上述迭代方法会忽略 Symbol 属性

```javascript
let user = { name: "John", age: 30 };
/*
Object.keys(user) —> ["name","age"]
Object.values(user) —> ["John",30]
Object.entries(user) —> [["name":"John"],["age",30]]
*/
```

- Object.getOwnPropertySymbols：返回所有 Symbol 属性的键组成的数组
- Reflect.ownKeys(obj)：返回所有键

## 转换对象使用数组方法

1. Object.entries(obj) —> 转成键值对组成的数组
2. 对数组使用数组方法，如 map、filter
3. Object.fromEntries(array) —> 将结果数组转换成对象

```javascript
let prices = { banana: 1, orange: 2, meat: 4 };
let doublePrices = Object.fromEntries(
  Object.entries(prices).map((item) => [item[0], item[1] * 2])
);
alert(doublePrices.meat); //8
```

# 解构赋值

- 将数组或对象"拆包"到多个变量的语法糖
- 不修改数组和对象

## 数组解构

- 语法：`let [item1 [=default],item2,...rest]=array`
- = 右侧可以是任何可迭代对象（使用 for...of)
- = 左侧可以是任何可赋值的东西

```javascript
let arr = ["John", "Smith"];
let [firstName, surname] = arr;
//firstName=arr[0]
//surname=arr[1]

//更优雅的写法
let [fristName, surname] = "John Smith".split(" ");

// 解构可迭代对象
let [a, b, c] = "xyz"; //["x","y","z"]
let [one, two, three] = new Set([1, 2, 3]);

//给对象属性赋值
let user = {};
[user.name, user.surname] = "John Smith".split(" ");

//与 Object.entries(obj)一起遍历对象属性
let user = { name: "John", age: 30 };
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); //name:John,then age:30
}

//与 Map 一起遍历[key,value]
let user = new Map();
user.set("name", "John");
user.set("age", 30);
for (let [key, value] of user) {
  alert(`${key}:${value}`); //name:John,then age:30
}
```

### 通过额外的逗号丢弃元素

```javascript
//跳过第2个元素，剩下的元素也被跳过了
let [firstName, , title] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republici",
];
alert(firstName); //Julius
alert(title); //Consul
```

### 快速交换变量

```javascript
let var1 = 1;
let var2 = 2;
let var3 = 3;

[var1, var2, var3] = [var2, var3, var1];
```

### 收集剩余的元素到数组中

- 数组变量名加...
- 数组变量是最后一个参数

```javascript
let [name1, name2, ...rest] = [
  "Julius",
  "Caesar",
  "Consul",
  "of the Roman Republic",
];
alert(rest); // Consul, of the Roman Republic
```

### 提供默认值

- = 右边数组元素比左边变量少，变量会被赋值 undefined
- 默认值可为表达式或函数调用（但只会在变量缺失赋值元素时计算或调用）

```javascript
let [firstName, surname] = [];
alert(firstName); //undefined
alert(surname); //undefined

//提供常规默认值
let [name = "Guest", surname = "Anonymous"] = ["Julius"];
alert(name); //Julius
alert(surname); //Anonymous

//提供函数调用默认值
let [name = prompt("name?"), surname = prompt("surname?")] = ["Julius"];
```

## 对象解构

- 语法：`let {prop [:varName][=default],...rest}=object`
- 按属性名赋值，顺序不重要

```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200,
};
//options.title、options.width、options.height被赋值给对应变量
let { title, width, height } = options;
//变量顺序不重要
let { width, height, title } = options;
//只取需要的属性值
let { title } = options;
```

### 赋值给不同名称的变量（冒号映射）

```javascript
let options = { title: "Menu", width: 100, height: 200 };
//{原属性名:新变量}
let { width: w, height: h, title } = options;
//w=100,h=200,title=Menu
```

### 提供默认值

- 默认值可为表达式或函数调用（但只会在变量缺失赋值元素时计算或调用）

```javascript
let options = { title: "Menu" };
let { width = prompt("width?"), title = prompt("title?") } = options;
let { width: w = 100, height: h = 200, title } = options;
```

### 收集剩余的属性到对象中

```javascript
let options = {
  title: "Menu",
  height: 100,
  width: 200,
};
//title:"Menu",rest:{height:100,width:200}
let { title, ...rest } = options;
```

### 不使用 let 时的陷阱

- {}会被当成一个代码块
- 解决：用()包起来

```javascript
let options = {
  title: "Menu",
  height: 100,
  width: 200,
};
let title, width, height;

//{title,width,height}=options;//报错
({ title, width, height } = options); //正常
```

## 嵌套解构

```javascript
let options = {
  size: { width: 100, height: 200 },
  items: ["Cake", "Donut"],
  extra: true,
};

let {
  size: { width, height }, //size对象解构到这里
  items: [item1, item2], //items数组解构到这里
  title = "Menu", //使用默认值
} = options;
```

## 智能函数参数

- 问题：
  1. 传递函数参数需要严格按照位置
  2. 默认值参数需要写很多 undefined 默认值`showMenu("My Menu",undefined,undefined,["Item1","Item2"])`
- 解决：用对象传递参数，函数负责将对象解构到各参数
- 注意：所有参数使用默认值，需要传递空对象{}（可指定整个参数对象默认值为{}）

```javascript
let options = { title: "My menu", items: ["Item1", "Item2"] };

function showMenu({
  title = "Untitled",
  width = 200,
  height = 100,
  items = [],
}) {
  //title,items提取于options
  //width,height使用默认值
  alert(`${title}${width}${height}`);
  alert(items);
}
showMenu(options);

//支持嵌套解构和冒号映射
let options = { title: "My menu", items: ["Item1", "Item2"] };
function showMenu({
  title = "Untitled",
  width: w = 100,
  height: h = 200,
  items: [item1, item2],
}) {
  alert(`${title}${w}${h}`); //My menu 100 200
  alert(item1); //Item1
  alert(item2); //Item2
}
showMenu(options);

showMenu({}); //所有参数都取默认值
//showMenu()；会报错
//重写showMenu,使用空对象作为整个参数对象的默认值
function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  //...
}
showMenu(); //正常
```
